<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CuiTalk</title>
  
  <subtitle>记录成长与美好</subtitle>
  <link href="https://cuifugang.github.io/atom.xml" rel="self"/>
  
  <link href="https://cuifugang.github.io/"/>
  <updated>2022-06-23T11:04:19.574Z</updated>
  <id>https://cuifugang.github.io/</id>
  
  <author>
    <name>CuiTalk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://cuifugang.github.io/2022/06/23/TTS%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    <id>https://cuifugang.github.io/2022/06/23/TTS%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90/</id>
    <published>2022-06-23T11:04:19.574Z</published>
    <updated>2022-06-23T11:04:19.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TTS-插件分析"><a href="#TTS-插件分析" class="headerlink" title="TTS 插件分析"></a>TTS 插件分析</h1><table><thead><tr><th>名称</th><th>评分</th><th>下载量</th><th>已有功能</th><th>用户痛点</th></tr></thead><tbody><tr><td><a href="https://chrome.google.com/webstore/detail/read-aloud-a-text-to-spee/hdhinadidafjejdhmfkjgnolgimiaplp">Read Aloud</a></td><td>4.3</td><td>200w+</td><td>1. read webpage (pdf/doc/webpage)<br /><br />2. 选中网页内容，转成语音<br />3. 支持快捷键<br /><br />4. 开源：<a href="https://github.com/ken107/read-aloud">https://github.com/ken107/read-aloud</a>.</td><td>1.可以控制速度；<br />2. 可以选择多种声音，但都是机器人<br />3. 读取文本的时候，没有highlight</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TTS-插件分析&quot;&gt;&lt;a href=&quot;#TTS-插件分析&quot; class=&quot;headerlink&quot; title=&quot;TTS 插件分析&quot;&gt;&lt;/a&gt;TTS 插件分析&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;评分&lt;/th&gt;
&lt;th&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>初步认识React中的Hook</title>
    <link href="https://cuifugang.github.io/2022/04/12/Hook/"/>
    <id>https://cuifugang.github.io/2022/04/12/Hook/</id>
    <published>2022-04-12T08:00:18.000Z</published>
    <updated>2022-04-12T08:00:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>准备某公司的面试，快速学习下React Hook的基础知识</p><span id="more"></span><h2 id="为什么会出现hook？"><a href="#为什么会出现hook？" class="headerlink" title="为什么会出现hook？"></a>为什么会出现hook？</h2><h3 id="1-为了解决在组件之间复用状态逻辑很难的问题；"><a href="#1-为了解决在组件之间复用状态逻辑很难的问题；" class="headerlink" title="1.  为了解决在组件之间复用状态逻辑很难的问题；"></a>1.  为了解决在组件之间复用状态逻辑很难的问题；</h3><h3 id="2-复杂的组件变得难以理解"><a href="#2-复杂的组件变得难以理解" class="headerlink" title="2.复杂的组件变得难以理解"></a>2.复杂的组件变得难以理解</h3><p>随着程序或者交互变得越来越复杂，组件中的逻辑变得越来越复杂，比如组件通常在 <code>componentDidMount</code> 和     <code>componentDidUpdate</code>的时候获取数据，但是同一个<code>componentDidMount</code>中也可能包含其他复杂的逻辑，如事件监听；之后还需要在<code>componentWillUnmount</code>中清除.</p><p>Hook将组件中相互关联的部分拆成了更小的函数，并非强制按照生命周期划分；</p><h3 id="3-难以理解的class"><a href="#3-难以理解的class" class="headerlink" title="3. 难以理解的class"></a>3. 难以理解的class</h3><p>class中的this关键字，让程序在运行时变得难以理解，出现了问题，难以定位； </p><h2 id="Hook是什么？什么时候使用"><a href="#Hook是什么？什么时候使用" class="headerlink" title="Hook是什么？什么时候使用"></a>Hook是什么？什么时候使用</h2><h3 id="Hook是什么"><a href="#Hook是什么" class="headerlink" title="Hook是什么"></a>Hook是什么</h3><p>它是一种特殊的函数；可以允许 <code>钩入</code>React的特性；比如可以在函数组件中使用useState hook访问react中的state；</p><h3 id="什么时候会用Hook"><a href="#什么时候会用Hook" class="headerlink" title="什么时候会用Hook"></a>什么时候会用Hook</h3><p>如果在函数中意识到需要添加一些数据到state，可以使用useState；</p><p>如果在函数中需要获取数据，或者更改dom，可以使用UseEffect；</p><h2 id="常用的hook"><a href="#常用的hook" class="headerlink" title="常用的hook"></a>常用的hook</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState()"></a>useState()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个叫 “count” 的 state 变量。</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">        Click me</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>useState</code>会返回两个值：当前状态和一个让你更新它的函数；</li><li>返回的函数可以在事件处理中直接调用</li></ul><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于 componentDidMount 和 componentDidUpdate:</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用浏览器的 API 更新页面标题</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">        Click me</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>UseEffect类似于class中的 <code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>， 用于执行数据获取、修改dom</li><li>当调用<code>useEffect</code>时，就是在告诉React在完成对DOM修改后，运行你的Effect函数；</li><li>每次DOM渲染之后，都会调用UseEffect；</li></ul><h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> locale = useContext(LocaleContext);</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>让你不使用组件嵌套就可以访问context</li></ul><h2 id="Hook的使用规则"><a href="#Hook的使用规则" class="headerlink" title="Hook的使用规则"></a>Hook的使用规则</h2><p>Hook就是Javascript的函数，他有两个使用规则</p><ul><li>只能在函数最外层调用hook，不能在循环、条件判断内部调用</li><li>只能在React<strong>函数组件</strong>中调用；不能在其他的JavaScript类中或者函数中调用</li><li></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;准备某公司的面试，快速学习下React Hook的基础知识&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://cuifugang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Hook" scheme="https://cuifugang.github.io/tags/Hook/"/>
    
    <category term="React" scheme="https://cuifugang.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>关于Promise，需要知道这些</title>
    <link href="https://cuifugang.github.io/2022/04/12/Promise/"/>
    <id>https://cuifugang.github.io/2022/04/12/Promise/</id>
    <published>2022-04-12T07:04:59.000Z</published>
    <updated>2022-04-12T07:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>准备某公司的面试，快速学习下mongo的基础知识</p><span id="more"></span><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Promise是一种构造函数，是异步编程的一种解决方案；</p><p>从语法上讲，它是一个对象。</p><p>Promise有三种状态：pending，resolve，reject</p><p>状态一旦改变，就不会再变；创造promise实例后，它会立即执行。</p><h2 id="为什么会出现promise"><a href="#为什么会出现promise" class="headerlink" title="为什么会出现promise"></a>为什么会出现promise</h2><p>在以前，处理很多异步请求时，会出现下面的代码：(恐怖的回调地狱)</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async1(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        async2(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            async3(<span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">                async4(funciton()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    async5(<span class="keyword">function</span>()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="regexp">//</span>...</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">            </span>))</span>; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise的用法"><a href="#Promise的用法" class="headerlink" title="Promise的用法"></a>Promise的用法</h2><p>Promise是一种构造函数，通过new创建实例</p><p>有 <code>all</code>, <code>reject</code>, <code>resolve</code>多个眼熟的方法；原型上有 <code>then</code>, <code>catch</code>类似的方法；</p><h3 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag=<span class="built_in">Math</span>.random()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(flag)</span><br><span class="line">        <span class="keyword">if</span>(flag&gt;<span class="number">0.5</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">            resolve(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">            reject(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">resule</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resule);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Promise是一种构造函数，所以使用new创建，中间接受一个function <code>() =&gt; &#123;&#125;</code></li><li>Resolve: 将promise的状态从pending转换为 <code>resolved</code>，异步操作执行成功后的回调函数；</li><li>Reject：将promise的状态从pending转换为 <code>reject</code>,异步操作执行失败后的回调函数</li><li>Promise创建后会有一些方法，比如 <code>then</code>和 <code>catch</code>, </li><li>Promise的关键是传递状态，通过使用维护状态、传递状态的方式使得回调函数能够及时调用；它比callback要灵活很多；</li><li>Promise只是返回某个 <code> 承诺</code>，并不意味着函数一定拿到了结果，处于 <code>pending</code>的状态。这时候，JS运行器还是可以继续往下执行；等Promise的状态从<code>pending</code>变成了 <code>resolve</code>或者 <code>reject</code>，程序会回过头来继续执行对应的操作；</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>闭包是一个函数，存在于另外一个函数中；</li><li>闭包可以访问到父级函数的变量，并且该变量不会被销毁；</li><li>为了避免全局变量容易被污染和修改的问题，所以引入了闭包；</li><li>闭包的原理是利用了作用域链的特性；如果在自己函数中不存在则会一直往上层寻找；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;准备某公司的面试，快速学习下mongo的基础知识&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://cuifugang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="JavaScript" scheme="https://cuifugang.github.io/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
    <category term="回调" scheme="https://cuifugang.github.io/tags/%E5%9B%9E%E8%B0%83/"/>
    
    <category term="JavaScript" scheme="https://cuifugang.github.io/tags/JavaScript/"/>
    
    <category term="Promise" scheme="https://cuifugang.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 基础知识</title>
    <link href="https://cuifugang.github.io/2022/04/11/MongoDB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://cuifugang.github.io/2022/04/11/MongoDB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-11T15:48:53.000Z</published>
    <updated>2022-04-12T07:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>准备某公司的面试，快速学习下mongo的基础知识</p><span id="more"></span><h2 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">// 创建DB</span><br><span class="line">use &lt;DB_NAME&gt;  //如果有，就会切换过去，没有，则会创建；</span><br><span class="line"></span><br><span class="line">// 查看所有数据库</span><br><span class="line">show dbs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 删除数据库：</span><br><span class="line">db.dropDatabase();</span><br><span class="line"></span><br><span class="line">// 删除集合</span><br><span class="line">db.collection.drop();</span><br><span class="line"></span><br><span class="line">// 创建集合</span><br><span class="line">db.createCollection(name, options);</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> name: 要创建的集合名称</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> options: 可选参数, 指定有关内存大小及索引的选项:capped:boolean类型，是否创建固定大小的DB，如果为<span class="literal">true</span>，当达到最大值时，再插入数据，就会把最早的覆盖掉；</span></span><br><span class="line">比如： db.createCollection(&quot;mycol&quot;, &#123; capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125; )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 查看所有collection:</span><br><span class="line">show collections；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 插入</span><br><span class="line">db.&lt;Collection_NAME&gt;.insert(&#123;&quot;name&quot;: &quot;CuiTalk&quot;&#125;); //若插入的数据主键已经存在，则会抛DuplicateKeyException 异常，提示主键重复，不保存当前数据。</span><br><span class="line"></span><br><span class="line">db.collection.insertOne(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.collection.insertMany(</span><br><span class="line">   [ &lt;document 1&gt; , &lt;document 2&gt;, ... ],</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;,</span><br><span class="line">      ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">说明：</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> document：要写入的文档。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ordered：指定是否按顺序写入，默认 <span class="literal">true</span>，按顺序写入。</span></span><br><span class="line"></span><br><span class="line">// 更新</span><br><span class="line">db.&lt;Collection_name&gt;.update(&lt;query&gt;, &lt;update&gt;, &#123;upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt;&#125;);</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,<span class="literal">true</span>为插入，默认是<span class="literal">false</span>，不插入。</span></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash"> multi : 可选，mongodb 默认是<span class="literal">false</span>,只更新找到的第一条记录，如果这个参数为<span class="literal">true</span>,就把按条件查出来多条记录全部更新。</span></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash"> writeConcern :可选，抛出异常的级别。</span></span><br><span class="line">  </span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> 比如：db.col.update(&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB 教程&#x27;</span>&#125;,&#123;<span class="variable">$set</span>:&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB&#x27;</span>&#125;&#125;)</span></span><br><span class="line"> </span><br><span class="line">// 删除</span><br><span class="line">db.&lt;Collection_name&gt;.remove(&lt;query&gt;, &#123;justOne: bool, writeConcern: &lt;doc&gt;&#125;)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> query :（可选）删除的文档的条件。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> justOne : （可选）如果设为 <span class="literal">true</span> 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 <span class="literal">false</span>，则删除所有匹配条件的文档。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> writeConcern :（可选）抛出异常的级别。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 比如：db.col.remove(&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB 教程&#x27;</span>&#125;)；</span></span><br><span class="line">若想删除所有数据，则query为空：db.col.remove(&#123;&#125;)；</span><br><span class="line"></span><br><span class="line">// 查询</span><br><span class="line">db.&lt;Collection_name&gt;.find(&lt;query&gt;)</span><br><span class="line"></span><br><span class="line"> 说明：</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> 多个条件查询(and): 用逗号隔开：db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> 多个条件或(or): 使用关键字 <span class="variable">$or</span>:</span></span><br><span class="line"> db.col.find(</span><br><span class="line">                 &#123;</span><br><span class="line">                    $or: [</span><br><span class="line">                       &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">                    ]</span><br><span class="line">                 &#125;</span><br><span class="line">                ).pretty()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//支持按值类型查询$type</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="variable">$type</span>操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。下图显示mongodb中各种类型与值得对应关系；</span></span><br><span class="line">db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;)</span><br><span class="line">或</span><br><span class="line">db.col.find(&#123;&quot;title&quot; : &#123;$type : &#x27;string&#x27;&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  limit和skip</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">db.COLLECTION_NAME.find().<span class="built_in">limit</span>(NUMBER).skip(Number)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 排序</span><br><span class="line">可以指定按某个字段的升序和降序排列：升序(1)降序（-1）</span><br><span class="line">db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.find(&#123;&#125;,&#123;<span class="string">&quot;title&quot;</span>:1,_id:0&#125;).sort(&#123;<span class="string">&quot;likes&quot;</span>:-1&#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://fugangcui-1253116767.cos.ap-beijing.myqcloud.com/img/image-20220412001709221.png" alt="image-20220412001709221" style="zoom: 33%;" /><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>// 索引: 索引是一种特殊的数据结构，它存储在一个容易遍历的集合中，索引是对数据库表中一列或者多列的值进行排序的一种数据结构<br>db.collection.createIndex(keys, options)</p><blockquote><p>db.col.createIndex({“title”:1}) // 1为升序，-1为降序；<br>db.col.createIndex({“title”:1,”description”:-1}) // 为多个字段设置索引</p></blockquote><img src="https://fugangcui-1253116767.cos.ap-beijing.myqcloud.com/img/image-20220412003038470.png" alt="image-20220412003038470" style="zoom: 33%;" /><h3 id="聚合aggregate"><a href="#聚合aggregate" class="headerlink" title="聚合aggregate"></a>聚合aggregate</h3><h4 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate()"></a>aggregate()</h4><p>主要用于数据的处理：比如统计平均值，求和等；</p><p>语法： &gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</p><p>举例： <code> db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])</code></p><p>// 计算每个作者所写的文章数，使用aggregate()计算结果</p><img src="https://fugangcui-1253116767.cos.ap-beijing.myqcloud.com/img/image-20220412004312114.png" alt="image-20220412004312114" style="zoom:50%;" /><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>常见的聚合方法：</p><ul><li><p>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="operator">/</span><span class="operator">/</span>结果中值返回_id,tilte和author三个字段</span><br><span class="line">db.article.aggregate(</span><br><span class="line">    &#123; $project : &#123;</span><br><span class="line">        title : <span class="number">1</span> ,</span><br><span class="line">        author : <span class="number">1</span> ,</span><br><span class="line">    &#125;&#125;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li><li><p>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// $match用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理</span><br><span class="line">db.articles.aggregate( [</span><br><span class="line">                        &#123; $match : &#123; score : &#123; $gt : 70, $lte : 90 &#125; &#125; &#125;,</span><br><span class="line">                        &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;</span><br><span class="line">                       ] );</span><br></pre></td></tr></table></figure></li><li><p>$limit：用来限制MongoDB聚合管道返回的文档数。</p></li><li><p>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</p></li><li><p>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</p></li><li><p>$group：将集合中的文档分组，可用于统计结果。</p></li><li><p>$sort：将输入文档排序后输出。</p></li><li><p>$geoNear：输出接近某一地理位置的有序文档。</p></li></ul><h2 id="复制-replicaset"><a href="#复制-replicaset" class="headerlink" title="复制(replicaset)"></a>复制(replicaset)</h2><h4 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h4><p>mongo复制是把数据同步到多个机器节点的过程；</p><p>通过复制这种方式，进行数据备份；提高了数据的可靠性并且保证数据安全；</p><ul><li>保障数据的安全性</li><li>数据高可用性 (24*7)</li><li>灾难恢复</li><li>无需停机维护（如备份，重建索引，压缩）</li><li>分布式读取数据</li></ul><h4 id="复制的原理"><a href="#复制的原理" class="headerlink" title="复制的原理"></a>复制的原理</h4><img src="https://fugangcui-1253116767.cos.ap-beijing.myqcloud.com/img/image-20220412141107608.png" alt="image-20220412141107608" style="zoom:50%;" /><ul><li>至少两个节点；一主一从；</li><li>主节点负责处理客户端请求，从节点负责从主节点同步数据；</li><li>任何节点都可以作为主节点；</li><li>所有的写入操作都发生在主节点上；</li><li>Replicset中，如果主节点down掉，会从从节点中选取一个节点作为主节点。从而保证服务继续正常运行；</li></ul><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><h4 id="为什么要有分片"><a href="#为什么要有分片" class="headerlink" title="为什么要有分片"></a>为什么要有分片</h4><ul><li>满足海量数据快速增长的需求</li><li>当海量数据存储时，一台机器可能由于空间不足或者满足不了读写速度的要求，所以考虑把数据拆成小块，分布到多台server中；</li><li>复制所有的写入操作到主节点</li><li>延迟的敏感数据会在主节点查询</li><li>单个副本集限制在12个节点</li><li>当请求量巨大时会出现内存不足。</li><li>本地磁盘不足</li><li>垂直扩展价格昂贵</li></ul><h2 id="MongoDB和关系型数据库比较"><a href="#MongoDB和关系型数据库比较" class="headerlink" title="MongoDB和关系型数据库比较"></a>MongoDB和关系型数据库比较</h2><ul><li>mongo db基于文档，每一个数据是以key-value 存储，结构上 更灵活，没有固定的表结构的概念，适合一些快速发展的业务中；可以根据业务的需要，动态调整数据格式</li><li>ACID(原子性、一致性、隔离性、持续性)，从事务的角度来说，mysql更完整，做的更好一些；mongo早期的版本是不支持事务的；2018年之后，才开始支持，而且默认是关闭的</li><li>mongo适用于大量的数据，非固定结构化的数据存储；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;准备某公司的面试，快速学习下mongo的基础知识&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://cuifugang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="技术" scheme="https://cuifugang.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="数据库" scheme="https://cuifugang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>一个新的开始</title>
    <link href="https://cuifugang.github.io/2022/04/07/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>https://cuifugang.github.io/2022/04/07/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</id>
    <published>2022-04-07T14:35:15.000Z</published>
    <updated>2022-04-07T14:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个新的开始。</p><blockquote><p> Every day is a fresh day</p></blockquote><p>花了两天的时间，把自己的blog迁回到github pages，并使用了<a href="https://github.com/xaoxuu/hexo-theme-stellar">stellar</a>主题。 一个对程序员非常友好的主题，简约可配置；</p><p>在这里会记录自己的日常，会记录一些自己的思考和成长；希望当回首的时候，会有一些怀念和感动；</p><img src="https://fugangcui-1253116767.cos.ap-beijing.myqcloud.com/img/223855-Fresh-Start-New-Beginning.jpg" alt="Fresh Start New Beginning Pictures, Photos, and Images for Facebook,  Tumblr, Pinterest, and Twitter" style="zoom:150%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个新的开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; Every day is a fresh day&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;花了两天的时间，把自己的blog迁回到github pages，并使用了&lt;a href=&quot;https://github.co</summary>
      
    
    
    
    <category term="杂谈" scheme="https://cuifugang.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
